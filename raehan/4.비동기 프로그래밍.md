# 비동기 프로그래밍

비동기 프로그래밍은 특정 작업이 완료될 때까지 기다리지 않고 다른 작업을 계속 수행하는 프로그래밍 방식이다.

## 1. 값으로 다루는 비동기

Promise는 비동기 작업의 결과를 값으로 다룰 수 있게 하는 객체이자 규약이다.

### 1.1. Promise

Promise는 비동기 작업의 성공, 실패를 처리하는 데 사용하는 객체이다. 비동기를 다루는 표준화된 값과 규약은 개발자와 언어가 이를 정확하고 안전하게 다룰 수 있게 한다. Promise는 비동기 작업 완료와 관계없이 즉시 객체를 생성하여 값으로 다룰 수 있게 하고, 결과가 필요한 시점에 꺼내 보거나 에러를 처리할 수 있도록 한다.

Promise는 생성 즉시 대기(pending) 상태로 시작하고 작업이 성공하면 이행(fulfilled) 상태, 실패하면 거부(rejected) 상태로 전환된다. Promise는 여러 Promise를 조합(합성)하여 순차적으로 실행하거나 동시 실행하도록 제어할 수 있고, async/await로 간단하게 표현 가능하다.

#### Promise의 변천사

1. **ECMAScript 2015(ES6)**

   - Promise: 비동기 작업의 성공 또는 실패를 처리하는 객체
   - Promise.all: 병렬로 실행된 모든 Promise가 완료될 때까지 기다림
   - Promise.race: 병렬로 실행된 여러 Promise 중 가장 먼저 완료된 Promise의 결과나 에러를 반환
   - Promise.resolve: 기존 값을 Promise로 변환하거나 이미 Promise인 값을 그대로 반환
   - Promise.reject: 실패한 이유와 함께 거부된 Promise를 반환

2. **ECMAScript 2017(ES8)**

   - async/await: 비동기 함수를 정의하고 Promise의 결과를 기다릴 수 있는 구문

3. **ECMAScript 2018(ES9)**

   - promise.finally: Promise가 완료되면(성공 또는 실패와 관계없이) 항상 실행되는 콜백을 지정
   - for await...of: 비동기 이터러블 객체를 반복할 수 있는 구문
   - AsyncIterator: 비동기 이터레이션을 지원하는 인터페이스
   - AsyncGenerator: 비동기 작업을 수행하면서 값을 생성할 수 있는 비동기 제너레이터 함수

4. **ECMAScript 2020(ES11)**

   - Promise.allSettled: 여러 Promise를 병렬로 실행하고 모든 Promise가 완료될 때까지 기다림

5. **ECMAScript 2021(ES12)**

   - Promise.any: 여러 Promise 중 가장 먼저 이행된 Promise의 값을 반환

6. **ECMAScript 2022(ES13)**
   - Array.fromAsync: 비동기 이터러블을 처리하여 배열을 생성

#### delay 함수

delay 함수는 time 만큼 대기 후 value 값을 반환하는 Promise를 생성하여 즉시 반환하는 함수이다.

```typescript
function delay<T>(time: number, value: T): Promise<T> {
  return new Promise((resolve) => setTimeout(resolve, time, value));
} // setTimeout의 3번째 인자부터는 첫 콜백 함수의 인자로 들어간다.
```

```typescript
delay(100, 2)
  .then((result) => console.log(result)) // 2
  .then(() => delay(100, 3))
  .then((result) => console.log(result)); // 3
```

```typescript
(async () => {
  const result = await delay(100, 4);
  console.log(result);
})(); // 4
```

### 1.2. new Promise()를 직접 사용해본 적 있는가?

글쓴이가 면접 자리에서 종종 하는 질문:

- 실제 업무에서 new Promise()를 직접 사용해본 경험이 있나요?
- 학습이나 실습 과정에서 또는 팀원들과 함께 작업할 때 실제 서비스 코드에서 new Promise()를 활용한 사례가 있나요?
- Promise 인스턴스를 인자로 받아 처리하는 함수를 구현해본 적이 있나요?
- Promise.all이나 Promise.race를 사용해본 경험은 있나요?

예전에는 콜백 기반의 비동기 제어 방식이 많아 콜백을 Promise 형태로 감싸기 위해 new Promise()를 직접 작성했다.

만약 Promise.all이나 Promise.race와 달리 기존에 제공되지 않는 고유한 방식의 병렬 실행 제어 함수를 구현해야 한다면 new Promise() 또는 이와 유사한 기법을 통해 Promise를 직접 생성하고 제어하는 로직이 필요할 수 있다.

이런 능력과 경험이 요구되는 작업의 몇 가지 예시:

- Promise.all과 다르게 동시 실행 개수를 제한하는 병렬적 함수 구현
- 더 나은 UI 반응성을 위한 애니메이션과 데이터 요청의 동시성 핸들링
- 서버사이드에서 데이터 가져오기, 저장하기, 렌더링 최적화
- 배치 작업 및 CronJob과 같은 정기 작업을 스케줄링하고 병렬 처리를 통한 작업 효율 최적화
- Node.js에서 파일을 스트림으로 읽고 스트림으로 쓰면서 제너레이터를 결합하여 사용
- 데이터베이스를 핸들링하는 재사용 가능한 함수 라이브러리 구현

### 1.3. Promise.race

Promise.race는 병렬로 실행된 여러 Promise 중 가장 먼저 완료된 Promise의 결과나 에러를 반환한다.

```typescript
const promise1 = new Promise((resolve) => setTimeout(resolve, 500, "one"));

const promise2 = new Promise((resolve) => setTimeout(resolve, 100, "two"));

await Promise.race([promise1, promise2]).then((value) => {
  console.log(value); // two
});
```

### 1.4. I/O 작업에 타임아웃 설정하기

API 응답이 5초 이상 지연되었을 때, 메시지를 보여주려 한다면 Promise.race를 활용하면 좋다.

```typescript
function getRandomValue<T>(a: T, b: T): T {
  const randomIndex = Math.floor(Math.random() * 2);
  return randomIndex === 0 ? a : b;
}

type User = {
  name: string;
};

function getFriends(): Promise<User[]> {
  return delay(getRandomValue(60, 6_000), [
    { name: "Marty" },
    { name: "Michael" },
    { name: "Sarah" },
  ]);
}

const result = await Promise.race([getFriends(), delay(2_000, "timeout")]);

if (result === "timeout") {
  console.log("The current network environment is not stable.");
} else {
  const friends = result as User[];
  console.log(
    "Friend list rendering:",
    friends.map(({ name }) => `<li>${name}</li>`)
  );
}
```

최근에는 AbortController가 추가되어 fetch와 함께 사용할 수 있지만 Promise.race를 활용한 방법처럼 기본기와 응용력이 뛰어나면 fetch 외의 다양한 상황에서도 비동기 작업을 효과적으로 처리할 수 있다.

추가로 예제는 간단하게 만든 것으로 실제로는 Promise.race에 시간이 지나면 에러를 전파하는 Promise를 전달하거나, Timeout과 같은 타입을 정의하여 타입 좁히기가 동작하도록 구성하면 좋다.

### 1.5. 응답 속도에 따라 다른 전략으로 UI 렌더링하기

만약 API 응답이 100ms내로 완료되면 즉시 렌더링, 아니라면 로딩 표시 후 응답이 완료되면 렌더링하도록 할 때 Promise.race를 활용 가능하다.

```typescript
function toggleLoadingIndicator(show: boolean): void {
  if (show) {
    console.log("append loading...");
  } else {
    console.log("remove loading...");
  }
}

async function renderFriendsPicker(): Promise<void> {
  const friendsPromise = getFriends();

  const result = await Promise.race([friendsPromise, delay(100, "isSlow")]);

  if (result === "isSlow") {
    toggleLoadingIndicator(true);
    await friendsPromise;
    toggleLoadingIndicator(false);
  }

  const friends = await friendsPromise;
  console.log(
    "Friend list rendering:",
    friends.map(({ name }) => `<li>${name}</li>`)
  );
}

await renderFriendsPicker();
// If the response is fast (random)
// After 0.06 seconds
// Friend list rendering: <li>Marty</li><li>Michael</li><li>Sarah</li>

await renderFriendsPicker();
// If the response is slow (random)
// append loading...
// After 6 seconds
// remove loading...
// Friend list rendering: <li>Marty</li><li>Michael</li><li>Sarah</li>
```

### 1.6. Promise.all

Promise.all은 주어진 모든 Promise가 이행될 때까지 기다렸다가 모든 결과를 배열로 반환하는 함수이다.

주어진 Promise 중 하나라도 거부(reject)되면 Promise.all은 즉시 거부되고 거부 이유를 반환한다. 여러 비동기 작업을 병렬로 실행하고 모든 작업이 완료될 때까지 기다릴 때 유용하다.

```typescript
type File = {
  name: string;
  body: string;
  size: number;
};

function getFile(name: string, size = 1000): Promise<File> {
  return delay(size, { name, body: "...", size });
}

const files = await Promise.all([
  getFile("img.png", 500),
  getFile("book.pdf", 1000),
  getFile("index.html", 1500),
]);

console.log(files);
```

위 코드는 비동기적으로 파일을 가져오는 것을 표현하므로 총 실행 시간은 3000ms 정도지만 실제로는 가장 오래 걸리는 1500ms 후쯤 결과가 완성된다. 만약 위 코드에 거부된 Promise가 포함되면 어떻게 될까?

```typescript
try {
  const files = await Promise.all([
    getFile("img.png", 500),
    getFile("book.pdf", 1000),
    getFile("index.html", 1500),
    delay(500, Promise.reject("파일 다운로드 실패!")),
  ]);

  console.log(files); // 실행되지 않음
} catch (error) {
  console.error(error); // 약 500ms 뒤 파일 다운로드 실패!
}
```

비동기 작업 중 실패를 반환하는 Promise가 있다면 catch 블록으로 이동한다. Promise와 await를 함께 사용하면 비동기 작업의 에러를 try…catch 문으로 처리할 수 있다.

### 1.7. Promise.allSettled

Promise.allSettled는 주어진 모든 Promise가 완료될 때까지 기다린 후 각 Promise의 성공 결과나 실패 결과를 객체로 담아 반환한다. 이는 모든 Promise의 완료 상태를 확인하고 싶을 때 유용하다.

```typescript
const files = await Promise.allSettled([
  getFile("img.png"),
  getFile("book.pdf"),
  getFile("index.html"),
  Promise.reject("File download failed"),
]);

console.log(files);
// After about 1,000ms:
// [
//   { status: 'fulfilled', value: { name: 'img.png', body: '...', size: 1000 } },
//   { status: 'fulfilled', value: { name: 'book.pdf', body: '...', size: 1000 } },
//   { status: 'fulfilled', value: { name: 'index.html', body: '...', size: 1000 } },
//   { status: 'rejected', reason: 'File download failed' }
// ]
```

오해하지 말아야 할 것은 Promise.all 함수에 문제가 있어 Promise.allSettled 함수가 나온 것이 아니며 용도가 다르다. 에러가 전파되는 것을 원할 때는 여전히 Promise.all가 유용하다.

ES11 전에는 이런 상황을 어떻게 해결했을까? 간단하다. Promise를 값으로 잘 다룰 수 있다면, settlePromise 같은 간단한 함수를 만들어 map과 함께 사용하는 식으로 대체할 수 있다.

```typescript
const settlePromise = <T>(promise: Promise<T>) =>
  promise
    .then((value) => ({ status: "fulfilled", value }))
    .catch((reason) => ({ status: "rejected", reason }));

const files = await Promise.all(
  [
    getFile("img.png"),
    getFile("book.pdf"),
    getFile("index.html"),
    Promise.reject("File download failed"),
  ].map(settlePromise)
);

console.log(files);
```

1. settlePromise는 promise를 인자로 받아 then과 catch를 사용해 각 Promise의 상태를 처리한다.
2. then 블록에서는 status: 'fulfilled'와 함께 value를 반환하고 catch 블록에서는 status: 'rejected'와 함께 reason을 반환한다.
3. map을 사용하여 각 Promise에 settlePromise 함수를 적용하고 Promise.all을 사용하여 모든 Promise가 완료될 때까지 기다린다.
4. 그러면 Promise.allSettled와 동일한 결과를 반환한다.

### 1.8. Promise.any

Promise.race가 가장 먼저 완료된 Promise를 이행되든 거부되든 상관없이 즉시 그 결과나 에러를 반환한다면 Promise.any는 여러 Promise 중 가장 먼저 이행된(fulfilled) Promise의 값을 반환한다. 단 모든 Promise가 거부된 경우에는 거부된 모든 이유를 포함하는 단일 에러를 반환한다.

```typescript
const files = await Promise.any([
  getFile("img.png", 1500),
  getFile("book.pdf", 700),
  getFile("index.html", 900),
  new Promise((_, reject) =>
    setTimeout(() => reject("File download failed"), 100)
  ),
]);

console.log(files);
// After about 700ms
// { name: 'book.pdf', body: '...', size: 700 }

const allRejectedFiles = await Promise.any([
  new Promise((_, reject) =>
    setTimeout(() => reject("File download failed"), 200)
  ),
  new Promise((_, reject) =>
    setTimeout(() => reject("File download failed"), 100)
  ),
]);

console.log(allRejectedFiles);
// After about 200ms
// Uncaught (in promise) AggregateError: All promises were rejected
```

## 2. 지연성으로 다루는 비동기

### 2.1. Promise 실행을 지연하려면

아래와 같이 Promise.all에서 6개의 Promise를 한번에 실행하고 있는 것을 부하를 조절해 3개씩 2번에 걸쳐 실행되도록 병렬 실행 함수를 만드려면 어떻게 해야할까?

```typescript
type File = {
  name: string;
  body: string;
  size: number;
};

function getFile(name: string, size = 1000): Promise<File> {
  return delay(size, { name, body: "...", size });
}

async function test() {
  const files: File[] = await Promise.all([
    getFile("img.png"),
    getFile("book.pdf"),
    getFile("index.html"),
    getFile("img.png"),
    getFile("book.pdf"),
    getFile("index.html"),
  ]);

  console.log(files);
}

await test();
```

비동기 작업을 나눠 실행하는 executeWithLimit(promises, limit) 함수를 만들어보자.

```typescript
type File = {
  name: string;
  body: string;
  size: number;
};

function getFile(name: string, size = 1000): Promise<File> {
  return delay(size, { name, body: "...", size });
}

async function executeWithLimit<T>(
  promises: Promise<T>[],
  limit: number
): Promise<T[]> {
  const result1 = await Promise.all([promises[0], promises[1], promises[2]]);
  const result2 = await Promise.all([promises[3], promises[4], promises[5]]);
  return [...result1, ...result2];
}

async function test() {
  const files: File[] = await executeWithLimit(
    [
      getFile("img.png"),
      getFile("book.pdf"),
      getFile("index.html"),
      getFile("img.png"),
      getFile("book.pdf"),
      getFile("index.html"),
    ],
    3
  );

  console.log(files);
}

await test();
```

하지만 위 코드는 3개의 Promise를 병렬 실행 후 나머지 3개 Promise를 실행해 1000ms+1000ms 정도 소요될 기대와 달리 의도대로 동작하지 않는다. 실제로는 약 1000ms 만에 모든 Promise가 완료돼 Promise.all과 동일한 결과를 반환한다.

#### 2.1.1. Promise의 즉시 실행

Promise 객체는 생성되는 즉시 실행된다. 즉 getFile 함수가 호출되는 순간 이미 Promise가 시작된다. 따라서 3개씩 그룹화하여 Promise.all과 await로 대기하더라도 6개의 Promise는 모두 동시에 시작한다.

#### 2.1.2. 병렬 실행의 의미

Promise.all은 이미 실행된 모든 Promise를 받아 모두 완료될 때까지 대기했다가 각 Promise를 풀어낸 배열을 반환하는 함수일 뿐, Promise의 시작 자체를 제어하는 함수는 아니다.

두 번의 Promise.all 호출이 있더라도 각 그룹의 Promise는 이미 시작된 상태에서 대기하는 것이므로 전체 실행 시간에는 영향을 미치지 않는다.

결국 3개씩 그룹화하여 병렬로 실행하는 것처럼 보이지만 실제로는 모든 Promise가 동시에 시작되기 때문에 전체 실행 시간은 1000ms가 된다. 확인하기 위해 로그를 출력해보자.

```typescript
type File = {
  name: string;
  body: string;
  size: number;
};

function getFile(name: string, size = 1000): Promise<File> {
  console.log(`${name} start`);
  return delay(size, { name, body: "...", size });
}

async function executeWithLimit<T>(
  promises: Promise<T>[],
  limit: number
): Promise<T[]> {
  const result1 = await Promise.all([promises[0], promises[1], promises[2]]);
  const result2 = await Promise.all([promises[3], promises[4], promises[5]]);
  return [...result1, ...result2];
}

async function test() {
  const promises = [
    getFile("1-img.png"),
    getFile("2-book.pdf"),
    getFile("3-index.html"),
    getFile("4-img2.png"),
    getFile("5-book.pdf"),
    getFile("6-index.html"),
  ];

  const files: File[] = await executeWithLimit(promises, 3);

  console.log(files);
}

await test();
```

getFile 함수 안에 로그 출력을 추가하고 executeWithLimit 함수에 전달할 Promise 배열을 이전 줄에서 생성하도록 변경하면 로그를 출력할 수 있다.

이렇게 하면 시작 로그가 한번에 출력되고 1000ms 후쯤 결과가 출력될 것이다.

해결하려면 아직 Promise들이 실행되지 않은 상태에서 그룹을 나누고 각 그룹이 순차적으로 실행되도록 해야 한다. 그러려면 Promise의 실행을 지연시키는 방법이 필요하다. 사실 기호 몇 개만 추가하면 된다.

```typescript
async function executeWithLimit<T>(
  fs: (() => Promise<T>)[],
  limit: number
): Promise<T[]> {
  const result1 = await Promise.all([fs[0](), fs[1](), fs[2]()]);
  const result2 = await Promise.all([fs[3](), fs[4](), fs[5]()]);
  return [...result1, ...result2];
}

async function test() {
  const files: File[] = await executeWithLimit(
    [
      () => getFile("1-img.png"),
      () => getFile("2-book.pdf"),
      () => getFile("3-index.html"),
      () => getFile("4-img2.png"),
      () => getFile("5-book.pdf"),
      () => getFile("6-index.html"),
    ],
    3
  );

  console.log(files);
}

await test();
```

() => 와 ()를 추가하기만 했다. Promise를 함수로 감싸 즉시 실행시키지 않고 필요할 때 실행되도록 실행을 지연한 것이다. 이 예제는 해당하지 않지만 클로저를 통해 외부 컨텍스트도 전달 가능하다.

### 2.2. AI가 명령형으로 구현한 동시성 핸들링 함수

질문:

fs를 limit개씩 나눈 다음 limit개씩 나누어 실행하는 함수로 만들어줘. `async function executeWithLimit(fs: (() => Promise)[], limit: number): Promise<T[]> {}...`

답변:

제시된 함수 서명을 따르는 executeWithLimit 함수를 작성해드리겠습니다. 이 함수는 주어진 비동기 함수 배열을 주어진 제한 개수로 나누어 순차적으로 실행합니다. 이를 통해 병렬로 실행할 작업의 수를 제한할 수 있습니다.

```typescript
async function executeWithLimit<T>(
  fs: (() => Promise<T>)[],
  limit: number
): Promise<T[]> {
  const results: T[] = [];

  for (let i = 0; i < fs.length; i += limit) {
    const batchPromises: Promise<T>[] = [];

    for (let j = 0; j < limit && i + j < fs.length; j++) {
      batchPromises.push(fs[i + j]());
    }

    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);
  }

  return results;
}

async function test() {
  const files: File[] = await executeWithLimit(
    [
      () => getFile("1-img.png"),
      () => getFile("2-book.pdf"),
      () => getFile("3-index.html"),
      () => getFile("4-img2.png"),
      () => getFile("5-book.pdf"),
      () => getFile("6-index.html"),
      () => getFile("7-img.png"),
    ],
    3
  );

  console.log(files);
}

await test();
```

### 2.3. 함수형으로 구현한 동시성 핸들링 함수

executeWithLimit 함수의 구현을 리스트 프로세싱 관점으로 계획하면 아래와 같다:

- [() => P, () => P, () => P, () => P, …]
- [[() => P, () => P, () => P], …] → 3개씩 그룹화
- [[P, P, P], …] → 함수 실행
- [P<[T, T, T]>, …] → 3개씩 대기하도록 Promise.all로 감싸기
- P<[[T, T, T], …] ]> → Promise.all들의 결과 꺼내기
- P<[T, T, T, T, …]> → 1차원 배열로 평탄화...

#### 2.3.1. chunk(size, iterable) 함수

chunk 함수는 주어진 크기(size)로 이터러블(iterable)을 나누는 리스트 프로세싱 함수이다. 이 함수는 이터레이터를 생성하고 각 청크를 반환한다.

```typescript
function* chunk<T>(size: number, iterable: Iterable<T>): IterableIterator<T[]> {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const arr = [
      ...take(size, {
        [Symbol.iterator]() {
          return iterator;
        },
      }),
    ];
    if (arr.length) yield arr;
    if (arr.length < size) break;
  }
}
```

```typescript
class FxIterable<A> {
  //   ...
  chunk(size: number) {
    return fx(chunk(size, this));
  }
}
```

```typescript
fx([1, 2, 3, 4, 5])
  .chunk(2)
  .map((arr) => arr.map((a) => a * 10)) // [arr: number[]], [a: number]
  .forEach((arr) => console.log(arr));
```

chunk 함수는 이터러블을 이터레이터로 만들어 순회하면서 주어진 size만큼의 요소를 배열로 그룹화하여 반환한 다음, 더 이상 그룹화할 요소가 없으면 루프를 종료한다.

#### 2.3.2. chunk로 시작하여 executeWithLimit 구현하기

executeWithLimit 함수를 계획대로 리스트 프로세싱에 기반하여 구현하고 실행해보자.

fromAsync는 ECMAScript에는 도입되었지만 아직 타입스크립트에는 도입되지 않은 Array.fromAsync의 핵심 기능을 구현한 함수이다.

```typescript
async function fromAsync<T>(
  iterable: Iterable<Promise<T>> | AsyncIterable<T>
): Promise<T[]> {
  const arr: T[] = [];
  for await (const a of iterable) {
    arr.push(a);
  }
  return arr;
}
```

```typescript
const executeWithLimit = <T>(
  fs: (() => Promise<T>)[],
  limit: number
): Promise<T[]> =>
  fx(fs)
    .chunk(limit)
    .map((fs) => fs.map((f) => f()))
    .map((ps) => Promise.all(ps))
    .to(fromAsync)
    .then((arr) => arr.flat());

async function test() {
  const files: File[] = await executeWithLimit(
    [
      () => getFile("1-img.png"),
      () => getFile("2-book.pdf"),
      () => getFile("3-index.html"),
      () => getFile("4-img2.png"),
      () => getFile("5-book.pdf"),
      () => getFile("6-index.html"),
      () => getFile("7-img.png"),
    ],
    3
  );

  console.log(files);
}

await test();
```

### 2.4. 효과적인 비동기 핸들링으로 가는 계단 - 지연성

executeWithLimit 함수 구현의 핵심은 지연성이다. 지연성은 효과적인 비동기 핸들링으로 나아가는 데 중요한 징검다리 역할을 한다.

- executeWithLimit 함수는 Promise 실행을 지연한 함수를 인자로 받는다.
- map(fs => fs.map(f => f()))는 executeWithLimit가 인자로 받은 모든 함수를 실행하는 것처럼 보이지만 이때 map은 Array의 map과 달리 지연 평가되는 map이다.
- 따라서 fromAsync에서 하나의 요소를 꺼낼 때 해당 청크 안에 있는 함수들만 실행하고 그다음 번 map에서 Promise.all로 감싼다.
- fromAsync는 이 결과를 for await...of로 꺼내므로 Promise.all의 결과를 대기 후 꺼낸다.
- 결과적으로 fromAsync는 지연된 비동기 작업을 순차적으로 평가하여 배열에 담아간다.
- 이는 비동기 작업 평가가 지연된 로직이 담긴 리스트를 fromAsync 이전에 만들어두었기 때문에 가능한 동작이자 코드 표현이다.

#### 2.4.1. 지연성을 더욱 잘 활용한 함수 합성으로 코드를 더 간결하게 만들기

chunk와 map은 지연 평가되는 함수이므로 순서를 변경해 더 간결하게 작성 가능하다.

```typescript
const executeWithLimit = <T>(
  fs: (() => Promise<T>)[],
  limit: number
): Promise<T[]> =>
  fx(fs)
    .map((f) => f())
    .chunk(limit)
    .map((ps) => Promise.all(ps))
    .to(fromAsync)
    .then((arr) => arr.flat());
```

map(f => f())가 어느 시점에 무엇에 의해 평가되는지 정확히 알고 있다면 f()가 실행되는 시점을 예측할 수 있다.

- fx(fs).map(f => f()).chunk(limit).map(ps => Promise.all(ps)) 코드 부분까지는 아무것도 실행되지 않는다.
- fromAsync 내부의 for await...of 구문에서 이터레이터가 처음 소비될 때 3개의 f가 실행되고 그룹화되어 Promise.all에 전달된다.

어떤 문제 상황에서는 new Promise()나 async/await를 사용하는 명령형 패러다임이 더 적합할 수 있다. 그러나 대부분의 비동기 상황에서는 지연성과 리스트 프로세싱을 활용하는 것이 더 효과적이고 안전하며 유리하고 적합하다.

지연 평가는 이처럼 언어의 중요한 요소이다. 단순히 성능 개선이나 최적화를 위한 도구에 그치지 않는다. 이터레이터와 전달받은 일급 함수를 원하는 시점에 평가하는 코드 패턴을 통해 로직을 재사용 가능한 형태로 만들 수 있다. 지연 평가와 일급 함수, 반복자 패턴을 활용한 리스트 프로세싱은 강력한 도구이자 언어적 표현이다.
