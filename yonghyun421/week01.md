## 1.1 객체지향 디자인 패턴의 반복자 패턴과 일급 함수

### 1.1.1 GoF의 반복자 패턴

- 반복자 패턴은 객체지향 디자인 패턴 중 하나로, 컬렉션의 요소를 순차적으로 접근하는 규약을 제시한다.

### 1.1.2 ArrayLike로부터 Iterator 생성하기

### 1.1.3 ArrayLike를 역순으로 순회하는 이터레이터 만들기

**이터레이터의 지연성을 이용한 reverse 함수 만들기**

- 이터레이터는 필요할 때마다 값을 하나씩 꺼내는 지연 평가를 지원하므로 모든 요소를 미리 뒤집어 둘 필요가 없다.
- 이로써 불필요한 연산과 메모리 사용량을 줄이며 필요한 시점에만 연산이 이루어지도록 개선할 수 있다.

### 1.1.4 지연 평가되는 map 함수

### 1.1.5 멀티패러다임의 교차점: 반복자 패턴과 일급 함수

- 정통적인 객체지향 디자인 패턴인 반복자 패턴이 함수형 패러다임의 일급 함수와 만나며 서로의 가치를 더욱 높이고 있다.
- 여기에 명령형 패러다임으로 작성되는 제너레이터까지 이 조합과 호환된다.
- 이 세 가지 패러다임이 하나의 언어 안에서 협력하여 객체지향, 함수형, 명령형 패러다임을 함께 고도화하고 언어를 멀티패러다임적으로 발전시키고 있다.

## 1.2 명령형 프로그래밍으로 이터레이터를 만드는 제너레이터 함수

- 제너레이터는 객체지향, 함수형 패러다임과 명령형 스타일이 서로 협력할 수 있게 하는 중요한 기반을 제공한다.

### 1.2.1 제너레이터 기본 문법

- 제너레이터는 명령형 스타일로 이터레이터를 작성할 수 있게 해주는 문법이다.
- 제너레이터는 function 키워드로 정의되며 호출 시 곧바로 실행되지 않고 이터레이터 객체를 반환하고 이 객체를 통해 함수의 실행 흐름을 외부에서 제어할 수 있다.

**yield와 next()**

- 제너레이터 함수가 반환한 이터레이터에 대해 next() 메서드를 호출하면 제너레이터 함수의 본문이 yield 키워드를 만날 때까지 실행된다.

**제너레이터와 제어문**

- 제너레이터 안에서 if문을 사용하여 이터레이터가 리스트를 만드는 로직을 제어할 수 있다.

**yield\* 키워드**

- yield\* 키워드는 제너레이터 함수 안에서 이터러블을 순회하며 해당 이터러블이 제공하는 요소들을 순차적으로 반환하도록 해준다.

**naturals 제너레이터 함수**

- 자연수의 무한 시퀀스를 생성하는 제너레이터 함수이다.
- naturals 제너레이터 함수는 무한 루프를 사용하여 자연수를 생성하지만 inter.next()를 호출할 때만 n을 반환하고 다시 일시 중지하기 때문에 프로세스나 브라우저가 멈추지 않는다.

## 1.3 자바스크립트에서 반복자 패턴 사례: 이터레이션 프로토콜

- 이터레이션 프로토콜은 자바스크립트의 규약이다.
- ES6에서 도입된 이터레이션 프로토콜은 어떤 객체가 이터러블인지 여부를 나타내는 규칙과 해당 규칙을 따르는 문법들을 제공하는 언어 전반의 규약이다.

### 1.3.1 이터레이터와 이터러블

- 만일 어떤 객체가 이터레이터를 반환하는 [Symbol.iterator]() { return { next() { …} }; } 메서드를 가지고 있다면 이터러블이다.
- 이터러블 객체는 자신이 가진 요소들을 이터레이터를 통해 순회할 수 있도록 하며 앞에서 설명한 반복자 패턴의 특성을 모두 갖추고 있다.

**이터레이터**

- Iterator: { value, done } 객체를 반환하는 next() 메서드를 가진 값
- Iterable: 이터레이터를 반환하는 [Symbol.iterator]() 메서드를 가진 값
- IterableIterator: 이터레이터면서 이터러블인 값
- 이터레이션 프로토콜: 이터러블을 for …of문, 전개 연산자 등과 함께 동작하도록 한 규약

### 1.3.2 언어와 이터러블의 상호작용

**전개 연산자와 이터러블**

- 전개 연산자(…)는 이터러블 객체의 모든 요소를 개별 요소로 확장하는 데 사용된다.

### 1.3.3 제너레이터로 만든 이터레이터도 이터러블

- 일반 함수로 이터레이터를 만들 수 있고, 제너레이터로 이터레이터를 생성할 수도 있으며, 일반 함수로 만든 이터레이터를 제너레이터 함수에 전달하거나 반대로 제너레이터에서 생성한 이터레이터를 일반 함수에 전달하여 for…of나 next()로 순회하며 yield를 수행할 수 있다.
- 타입스크립트에서는 이처럼 이터레이션 프로토콜을 통해 다양한 프로그래밍 패러다임으로 전환하고 조합할 수 있는 유연성을 제공한다.

## 1.4 이터러블을 다루는 함수형 프로그래밍

### 1.4.1 forEach 함수

- forEach 함수는 함수와 이터러블을 받아 이터러블을 순회하면서 각 요소에 인자로 받은 함수를 적용하는 고차 함수이다.

### 1.4.2 map 함수

- map 함수는 이터러블을 인자로 받아 이터레이터를 결과로 반환한다.

### 1.4.3 filter 함수

- filter 함수는 주어진 이터러블의 각 요소에 대해 조건을 확인하여 해당 조건을 만족하는 요소들만 반환하는 고차 함수이다.

## 1.5 이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유

- 상속은 코드를 추상화해 기능을 공유하는 좋은 도구이며 실제 개발 현장에서도 자주 사용한다.
- 그런데 반복자 패턴과 이터레이터를 지원하는 헬퍼 함수들은 상속이 아닌 인터페이스로 설계되어 있다.

### 1.5.2 상속이 아닌 인터페이스로 해결해야 하는 이유

**순회가 필요한 자료구조들인데 왜 Array를 상속받도록 만들지 않았을까**

- 이들은 모두 서로 다른 자료구조를 나타내며 각각 고유한 특성과 동작을 갖도록 설계되었기 때문이다.
- 만약 이들을 상속으로 연결하여 의존성을 생기게 하면 불필요한 복잡성이 생기고 최적화된 동작을 보장할 수 없게 된다.

**공통 로직을 공유할 수 있는 방법**

- 반복자 패턴처럼 공통의 인터페이스를 만들어 패턴화함으로써 다양한 자료구조에 사용할 공통 로직을 분리할 수 있다.
- 이러한 방법은 코드의 유지보수성을 높이고 다양한 자료구조에 동일한 패턴을 적용할 수 있는 더 나은 설계 방식을 제공한다.

### 1.5.3 인터페이스와 클래스 상속

- 인터페이스
  - 인터페이스는 클래스나 객체가 따라야 할 규약을 정의하며 이를 통해 다양한 클래스가 동일한 방식으로 상호작용할 수 있도록 한다.
  - 이러한 규약을 통해 공통된 행동을 강제하고 서로 다른 클래스들이 동일한 메서드를 구현하게 함으로써 다형성을 지원하고 코드의 유연성을 높일 수 있다.
  - 여러 클래스가 동일한 인터페이스를 구현하면 동일한 메서드 호출 패턴으로 일관된 설계를 할 수 있다.
- 상속
  - 상속은 기존 클래스의 속성과 메서드를 물려받아 새로운 클래스를 만드는 과정이다.
  - 이를 통해 코드 재사용성을 높이고 확장성을 확보할 수 있다.
  - 상속을 활용하면 공통 로직을 직접 구현한 뒤 이를 필요에 따라 확장하거나 변경할 수 있다.
  - 그러나 상속을 남용할 경우 코드의 결합도가 높아져 유지보수가 어려워질 수 있으므로 주의가 필요하다.
- 인터페이스는 규약을 제시하며 다양한 클래스가 동일한 형식의 동작을 구현하도록 유도하는 반면 상속은 공통 기능을 직접 구현한 뒤 이를 적절히 확장하는 데 초점을 둔다.

## 1.6 요약 정리

### 멀티패러다임의 시대

- 이제는 하나의 언어에서 명령형, 객체지향, 함수형 패러다임을 모두 활용할 수 있다.

### 멀티패러다임의 협력

- 각 패러다임은 그 자체로도 유용하지만 특정 문제에 가장 적합한 패러다임을 선택하거나 필요하다면 조합할 수 있는 유연성이야말로 멀티패러다임 언어의 장점이다.

### 반복자 패턴과 일급 함수

- 반복자 패턴은 컬렉션 요소를 순차적으로 접근하는 규약을 제시하고 이를 통해 다양한 형태의 컬렉션 데이터를 일관된 방식으로 순회할 수 있다.
- 함수형 프로그래밍의 핵심 요소인 일급 함수는 함수를 값처럼 취급해 다른 함수의 인자로 전달하거나 반환값으로 사용할 수 있다.

### 지연 평가와 고차 함수

- 지연 평가는 필요한 시점까지 계산을 미루어 메모리 사용량과 연산 비용을 줄여 성능을 향상하는 기법이다.

### 제너레이터 함수

- 제너레이터 함수는 이터레이터를 생성하는 문법적 장치로서 명령형 스타일로도 이터레이션 로직을 구현할 수 있게 한다.

### 타입스크립트와 이터레이션 프로토콜

- 이터러블 객체는 이터레이터를 통해 순회 가능한 구조를 갖추고 있다.
- 타입스크립트는 이러한 이터레이션 프로토콜에 대해 정교한 타입시스템을 제공하여 각 요소의 타입을 명확히 정의하고 코드 안전성을 한층 강화한다.

### 사용자 정의 이터러블

- 개발자는 직접 만든 객체에 이터레이션 프로토콜을 구현하여 사용자 정의 이터러블을 만들 수 있다.

### 상속 대신 인터페이스

- 상속은 객체지향 프로그래밍에서 중요한 개념이지만 다양한 자료구조를 일관성 있게 처리하려면 인터페이스와 이터레이션 프로토콜을 활용하는 편이 더 효율적일 수 있다.
