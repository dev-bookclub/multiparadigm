> 2주차 ( 2025.05.17 )
> 작성자: 김언화

---

# 2장: 함수형 프로그래밍과 타입 시스템 그리고 LISP

타입스크립트의 타입 추론을 통해 개발자는 명시적인 타입 선언 없이 안전한 코드 작성 가능
고차 함수와 제네릭을 활용하면 복잡한 함수형 프로그래밍 패턴을 구현 가능
객체지향 클래스와 함수형 함수의 결합을 통해 더욱 유연하고 강력한 코드 작성 가능

## 2.1 타입 추론

- 타입스크립트는 변수를 선언할 때 초기화된 값으로부터 타입을 추론
- 타입스크립트는 함수의 반환 타입도 자동으로 추론
- 타입스크립트는 객체 리터럴의 속성 타입 추론
- 타입스크립트는 함수 인자의 타입도 추론
  - 고차함수에서 타입추론 동작 : 인자로 전달 받은 함수의 인자 타입을 추론할 수 있어 화살표 함수를 간결하게 작성할 수 있다.
- 타입스크립트에서 제네릭 함수를 사용하면 하나의 함수가 다양한 타입을 지원하여 다형성이 높은 함수가 된다.

ex)

```
function identity<T>(arg: T): T {
  return arg;
}

const a = identity("hi"); // [const a: "hi"]

const b = identity(1); // [const b: 1]

const c = identity<string>("a"); // [const c: string]

const d = identity<number>(1); // [const d: number]


class User {}
const e = identity(new User()); // [const e: User]
const f = identity((n: number) => n % 2 === 1); // [const f: (n: number) =>  boolean]
```

identity 함수에 문자열 "hi" 를 전달하면 제네릭 타입 매개변수 T가 "hi" 가 되고 a 의 타입 역시 "hi" 로 추론된다.

- 타입스크립트는 **함수 오버로드** 를 지원하여 동일한 함수명으로 다양한 시그니처를 정의할 수 있다.

### constant 와 제네릭

constant 함수는 인자로 입력받은 값을 항상 그대로 돌려주는 함수를 반환한다.
이 함수는 특정 값을 캡처하여 호출될 때마다 해당 값을 반환하는 함수이다.

## 2.2 멀티패러다임 언어에서 함수형 타입 시스템

### 2.2.1 이터레이션 프로토콜과 타입

Iterator, Iterable, IterableIterator 에 일급 함수를 더한 함수형 고차 함수

```
interface IteratorYieldResult<T> {
  done?: false;
  value: T;
}

interface IteratorReturnResult {
  done: true;
  value: undefined;
}

interface Iterator<T> {
  next(): IteratorYieldResult<T> | IteratorReturnResult;
}

interface Iterable<T> {
  [Symbol.iterator](): Iterator<T>;
}

interface IterableIterator<T> extends Iterator<T> {
  [Symbol.iterator](): IterableITerator<T>;
}
```

## 2.2.2 함수형 고차 함수와 타입 시스템

map 과 타입
filter 와 타입
reduce 와 타입
reduce 함수 오버로드
reduce 의 에러 관리

## 2.3 멀티패러다임 언어와 메타프로그래밍 - LISP 로부터

고차함수들에 클래스를 결합하고 이터러블 패턴을 적용함으로써 데이터 스트림을 한층 가독성 높게 처리하는 구조를 만들어보자.

**메타프로그래밍 (metaprogramming)**
프로그램이 자기 자신이나 다른 프로그램을 데이터처럼 바라보며 분석,변경,생겅하거나 실행하는 프로그래밍 기법이다.
프로그램이 코드를 데이터로 다루면서 동적으로 조작하고 확장하는 이러한 방식은 전통적인 LISP 계열 언어에서 극대화 되었다.

## 2.3.1 Pipe Operator

```
forEach(printNumber,
  map(n => n % * 10,
    filter(n => n % 2 === 1,
      naturals(5)
    )
  ));
// 10
// 30
// 50

//Pipe Operator (Stage  2)
naturals(5)
  |> filter(n => n % 2 === 1, %)
  |> map(n => n * 10, %)
  |> forEach(printNumber, %)
// 10
// 30
// 50
```

Pipe Operator 코드는 괜찮은 편이지만 고차 함수의 첫 번째 인자 자리에 % 가 있어서 시선을 방해한다.

## 2.3.2 클래스와 고차 함수, 반복자, 타입 시스템을 조합하기

### 제네릭 클래스로 Iterable 확장하기

### FxIterble<A> 에 map 메서드 추가하기

### fx(iterable: Iterable<A>: FxIterable<A>로 간결하게 표현하기)

### filter, forEach 메서드 만들기

체이닝 방식

- 연속적인 메서드 호출을 통해 데이터 변환 방식을 직관적으로 표현
- 각 단계가 명화하게 드러나기 때문에 코드의 흐름을 쉽게 파악할 수 있다.

### reduce 메서드 만들기

타입스크립트에서 메서드 오버로드는 함수 오버로드와 동일한 방식으로 처리된다.

- 함수나 메서드의 시그니처를 여러 개 정의하고 실제 구현은 하나만 제공하는 방식

## 2.3.3 LISP(클로저) 에서 배우기 - 코드가 데이터, 데이터가 코드

**LISP** 의 가장 큰 특징은 '코드가 데이터이고 데이터가 코드' 라는 개념이다.

### 클로저

- 불변성과 일급 함수를 강조하며 동시성 프로그래밍과 관련된 강력한 기능들을 지원하는 언어
- 코드와 데이터를 동일하게 취급

### 클로저 - S-표현식

- 리스트 형태의 구문 표현을 의미
- 코드와 데이터를 동일한 구조(리스트)로 다룰 수 있다.

## 2.3.4 클로저에서 map 이 실행될 때

### 앞에서부터 두 개의 값 꺼내기

## 2.3.5 멀티패러다임 언어에서 사용자가 만든 코드이자 클래스를 리스트로 만들기

## 2.3.6 LISP 의 확장성 - 매크로와 메타 프로그래밍

### 매크로

### ->> 매크로

reject 함수를 적요안 코드를 파이프라인 형태로 표현해보자.

### reject 메서드를 FxIterable에 추가하기

### 코드, 객체, 함수가 협력하여 구현한 언어의 확장

## 2.3.7 런타임에서 동적으로 기능 확장하기

### to로 확장하고 객체지향적인 객체와 호흡하기

### Set의 집합 메서드와 함께 사용하기

### chain으로 확장하기
