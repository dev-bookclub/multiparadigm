> 1주차 ( 2025.05.11 )
> 작성자: 김언화

---

# 1장: 멀티패러다임이 현대 언어를 확장하는 방법

> 이 장에서는 이터레이션(반복)이라는 하나의 주제를 통해 객체지향, 함수형, 명령형 프로그래밍 패러다임이 어떻게 현대 프로그래밍 언어, 특히 자바스크립트에서 조화롭게 사용되어 언어의 표현력과 기능을 확장하는지 살펴봅니다.

## 1.1 객체지향 디자인 패턴의 반복자 패턴과 일급 함수

> 컬렉션의 내부를 숨기면서 요소에 순차적으로 접근하는 방법(반복자 패턴)과 함수를 값처럼 다루는 능력(일급 함수)을 결합하여, 유연하고 효율적인 데이터 처리 방식을 만듭니다.

### 1. GoF의 반복자 패턴 (Iterator Pattern)

- **반복자 패턴**은 객체지향 디자인 패턴 중 하나로, 컬렉션(배열, 리스트, 맵 등)의 내부 구현을 노출하지 않고, 그 안의 요소들에 하나씩 순차적으로 접근할 수 있는 표준화된 방법을 제공합니다.

- **TypeScript 인터페이스 예시:**

  - `IteratorYieldResult<T>` : 아직 반복이 끝나지 않았고, 다음 값(value)이 있음을 나타냅니다. done은 false이거나 생략됩니다.

    ```
    interface IteratorYieldResult<T> {
        dons?: false;
        value: T;
    }
    ```

  - `IteratorReturnResult`: 반복이 완료되었음을 나타냅니다. done은 true이고, value는 보통 undefined입니다.

    ```
    interface IteratorReturnResult {
        dons: true;
        value: undefined;
    }
    ```

  - `Iterator<T>`: next() 메서드를 가지며, 이 메서드는 IteratorYieldResult<T> 또는 IteratorReturnResult를 반환합니다. next()를 호출할 때마다 다음 요소를 가져옵니다.

    ```
    interface Iterator<T> {
        next(): IteratorYieldResult<T> | IteratorR-eturnResult;
    }
    ```

### 2. ArrayLike 로부터 Iterator 생성하기

- `ArrayLike<T>`란?: 실제 배열은 아니지만, 배열처럼 length 속성과 숫자 인덱스(0, 1, 2, ...)를 가진 객체를 말합니다. 예를 들어, 함수 내의 arguments 객체나 DOM의 NodeList가 여기에 해당됩니다.
- `ArrayLikeIterator<T>` 클래스 예시:
  - index 변수를 사용해 현재 위치를 추적합니다.
  - constructor에서 ArrayLike 객체를 받습니다.
  - `next()` 메서드:
    - index가 arrayLike.length보다 작으면, 현재 index 위치의 요소를 value로, done: false를 반환하고 index를 1 증가시킵니다.
    - index가 arrayLike.length에 도달하면, 더 이상 요소가 없으므로 value: undefined, done: true를 반환합니다.
- 지연 평가 (Lazy Evaluation)의 시작: iterator.next()를 호출하는 시점에만 다음 요소를 가져옵니다. 미리 모든 요소를 준비해두지 않기 때문에, 필요 없는 계산을 줄일 수 있고, 무한한 데이터 스트림도 다룰 수 있는 기반이 됩니다.

### 3. ArrayLike 를 역순으로 순회하는 이터레이터 (reverse 함수)

- 기존 `Array.prototype.reverse()`와의 차이점:
  - `Array.prototype.reverse()`: 원본 배열 자체를 즉시 뒤집습니다 (파괴적 변경). 모든 요소의 위치가 실제로 변경됩니다.
  - 이터레이터를 사용한 `reverse` 함수: 원본 ArrayLike 객체를 변경하지 않습니다. next()가 호출될 때마다 "뒤에서부터" 하나씩 요소를 가져오는 논리를 수행합니다. 실제 데이터는 그대로 두고, 접근 방식만 바꾸는 것입니다.
- 장점:
  - 비파괴적: 원본 데이터를 안전하게 보존합니다.
  - 지연성: next()를 호출할 때만 해당 요소를 가져오므로, 전체를 미리 뒤집을 필요가 없습니다. 만약 수백만 개의 요소 중 앞에서 몇 개만 역순으로 필요하다면 매우 효율적입니다.
  - 메모리 효율: 원본을 복사하거나 수정하지 않으므로 추가 메모리 사용이 적습니다.

#### 지연 평가의 효율성

```
const array = ['A', 'B', 'C', 'D', 'E', 'F'];
array.reverse(); // array의 순서를 ㅂ반대로 미리 모두 변경해둠
console.log(array); // ['F', 'E', 'D', 'C', 'B', 'A'];


const array2 = ['A', 'B', 'C', 'D', 'E', 'F'];
const reversed = reverse(array2);
console.log(array2); //['A', 'B', 'C', 'D', 'E', 'F']
console.log(reversed.next().value, reversed.next().value); //F E

```

- reverse 함수를 이용한 array2 에서는 필요한 만큼만 2번 역방향으로 순회하여 연산과 메모리 사용을 최소화

만일 원본도 필요하다면?

```
const array = ['A', 'B', 'C', 'D', 'E', 'F'];
const reversed = [...array].reverse(); // 복사하여 반전해둠
console.log(reversed[0], reversed[1], array[0], array[1] ); // F E A B


const array2 = ['A', 'B', 'C', 'D', 'E', 'F'];
const reversed2 = reverse(array2)
console.log(reversed2.next().value, reversed2.next().value, array2[0], arrya2[1]); // F E A B

```

- 전자는 원본을 지키기 위해 동일한 크기의 배열을 복사한 다음 전체를 반전 시킴
- 후자는 원래도 원본을 변경하지 않기 때문에 복사가 필요하지 않음

### 4. 지연 평가되는 map 함수

- 일급 함수 (First-class function): 함수를 변수에 할당하거나, 다른 함수의 인자로 전달하거나, 함수의 반환 값으로 사용할 수 있는 함수입니다. 자바스크립트의 함수는 모두 일급 함수입니다.
- 고차 함수 (Higher-order function): 함수를 인자로 받거나, 함수를 반환하는 함수입니다. map 함수는 변환 함수(transform)를 인자로 받으므로 고차 함수입니다.
- map 함수의 지연 평가:
  - map(transform, iterator) 형태로 호출됩니다.
  - map 함수 자체가 즉시 모든 요소를 변환하지 않습니다. 대신, 새로운 이터레이터를 반환합니다.
  - 이 새로운 이터레이터의 next()가 호출될 때, 원래 이터레이터의 next()를 호출하여 값을 가져오고, 그제야 transform 함수를 적용하여 변환된 값을 반환합니다.
  - 즉, "변환 규칙"만 정해두고, 실제 변환은 각 요소가 필요해지는 순간에 일어납니다.

### 5. 멀티패러다임의 교차점:

- 객체지향의 반복자 패턴: 데이터 순회 로직을 캡슐화하고 표준화합니다.
- 함수형의 일급 함수/고차 함수: 데이터 변환 로직을 유연하게 조합하고, 지연 평가를 가능하게 합니다.
- 이 둘의 조합은 map, filter, reduce 같이 데이터를 연쇄적으로 처리하는 파이프라인을 만들 때, 각 단계가 지연 평가되도록 하여 매우 강력하고 효율적인 코드를 작성할 수 있게 합니다.

---

## 1.2 명령형 프로그래밍으로 이터레이터를 만드는 제너레이터 함수

function과 yield 키워드를 사용하여, 일반적인 명령형 코드(루프, 조건문 등) 스타일로 이터레이터 로직을 더 쉽게 작성할 수 있게 합니다.

### 1. 제너레이터 기본 문법

**제너레이터**는 명령형 스타일로 이터레이터를 작성할 수 있게 해주는 문법입니다.

- `function*` 키워드로 함수를 정의합니다. (예: function\* myGenerator() { ... })
- 제너레이터 함수를 호출하면 즉시 실행되지 않고, 이터레이터 객체를 반환합니다.
- 함수 실행 흐름은 이 반환된 이터레이터 객체를 통해 외부에서 제어됩니다.

#### 2. yield 와 next()

- `yield` 키워드는 제너레이터 함수의 실행을 일시 중지시키고, yield 뒤에 오는 값을 이터레이터 결과 {value: ..., done: false}로 외부에 반환합니다.
- 외부에서 이터레이터의 `next()` 메서드를 다시 호출하면, 이전에 yield로 중지되었던 지점부터 함수 실행이 재개됩니다.
- 이 과정을 통해 함수 내부 상태는 유지되면서 값을 하나씩 순차적으로 생산할 수 있습니다.

#### 3. 제너레이터와 제어문

- 제너레이터 함수 내에서 if, for, while 등의 일반적인 제어문을 사용하여 이터레이터가 값을 생성하는 로직을 자유롭게 구성할 수 있습니다. 이는 클래스 기반 이터레이터보다 훨씬 직관적일 수 있습니다.

#### 4. naturals 제너레이터 함수

```
function* naturals() {
    let n = 1;
    while (true) {
        yield n++;
    }
}
```

- 이 함수는 1부터 시작하는 무한한 자연수 시퀀스를 만듭니다.
- while (true) 무한 루프를 사용하지만, yield 때문에 next()가 호출될 때만 다음 숫자를 생성하고 멈춥니다. 따라서 프로그램이 멈추지 않고, 필요한 만큼만 자연수를 뽑아 쓸 수 있습니다. 이는 지연 평가의 강력한 예시입니다.

#### 5. 제너레이터로 작성한 reverse 함수

- 클래스나 복잡한 객체 구조 없이, for 루프와 yield를 사용하여 간결하게 역순 이터레이터를 만들 수 있음을 보여줍니다.

---

## 1.3 자바스크립트에서 반복자 패턴 사례: 이터레이션 프로토콜

자바스크립트(ES6부터)는 언어 자체에 "반복"에 대한 표준 규약(프로토콜)을 도입하여, 다양한 데이터 구조들이 일관된 방식으로 순회될 수 있도록 했습니다.

### 1. 이터레이터와 이터러블

- 이터레이터 (Iterator): next() 메서드를 가지고, {value, done} 객체를 반환하는 객체입니다. (앞서 설명한 내용과 동일)
- 이터러블 (Iterable): [Symbol.iterator]() 메서드를 가진 객체입니다. 이 메서드를 호출하면 해당 객체를 순회할 수 있는 이터레이터를 반환해야 합니다.
  - Symbol.iterator는 자바스크립트의 내장 심볼 중 하나로, 객체가 기본 이터레이터를 제공하는 방식을 정의하는 데 사용됩니다.
- 이터러블 이터레이터 (IterableIterator): 이터레이터이면서 동시에 이터러블인 객체입니다. 즉, next() 메서드도 있고, [Symbol.iterator]() 메서드도 있어서 자기 자신(this)을 반환합니다. 제너레이터가 반환하는 객체가 대표적인 예입니다.

### 2. 이터러블의 활용:

- 객체가 이터러블 프로토콜을 따르면, for...of 문, 전개 연산자 (...), 구조 분해 할당, Array.from() 등 자바스크립트의 다양한 내장 기능들과 함께 자연스럽게 사용할 수 있습니다.
- 예: Array, String, Map, Set, DOM의 NodeList 등은 모두 내장 이터러블입니다.

### 3. 반복자 패턴의 재확인:

- 이터레이션 프로토콜은 본질적으로 앞서 설명한 GoF의 반복자 패턴을 자바스크립트 언어 차원에서 구현한 것입니다.
- 이를 통해 컬렉션의 내부 구조를 몰라도, [Symbol.iterator]()를 통해 이터레이터를 얻고 next()로 순회하는 일관된 방식을 사용할 수 있습니다.

---

## 1.4 이터러블을 다루는 함수형 프로그래밍

이터러블 프로토콜을 따르는 모든 데이터 구조에 대해 재사용 가능한 함수형 도구들(forEach, map, filter 등)을 만들 수 있습니다.

### 1. forEach(fn, iterable): 각 요소에 대한 반복 작업 수행

- 목적: 주어진 iterable의 각 요소에 대해 callback 함수를 한 번씩 실행합니다.
- 반환 값: undefined. 주로 callback 함수 내에서 부수 효과(side effect, 예: 콘솔 출력, DOM 조작 등)를 발생시킬 목적으로 사용됩니다.
- 특징: 이터러블을 즉시(eagerly) 순회하며 callback을 실행합니다.

### 2. map(fn, iterable): 각 요소를 변환하여 새로운 이터러블 생성

- 목적: 주어진 iterable의 각 요소에 transformFn (변환 함수)을 적용하고, 그 결과들로 구성된 새로운 이터러블 이터레이터를 반환합니다.
- 반환 값: 새로운 IterableIterator. 이 이터레이터는 원본 이터러블의 요소들을 변환한 값들을 필요할 때마다 생성합니다.
- 특징: 지연 평가(Lazy Evaluation). transformFn은 map 함수가 반환한 새로운 이터레이터의 next() 메서드가 호출될 때 비로소 실행됩니다. 즉, 모든 요소를 미리 변환해두지 않고, 실제로 해당 변환된 값이 필요해지는 시점에 계산합니다. 이는 불필요한 연산을 줄이고, 무한 이터러블도 다룰 수 있게 해줍니다.

### 3. filter(fn, iterable): 조건을 만족하는 요소들로 새로운 이터러블 생성

- 목적: 주어진 iterable의 각 요소에 대해 predicateFn (조건 함수)을 실행하고, 이 함수가 true를 반환하는 요소들만으로 구성된 새로운 이터러블 이터레이터를 반환합니다.
- 반환 값: 새로운 IterableIterator. 이 이터레이터는 조건을 만족하는 요소들만 필요할 때마다 생성합니다.
- 특징: filter 함수 내부 구현 시, 조건에 맞지 않는 요소는 건너뛰고 다음 요소를 가져오기 위해 this.next() (재귀) 또는 while 루프를 사용할 수 있습니다.

---

## 1.5 이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유

자바스크립트에서 다양한 종류의 데이터 컬렉션(배열, 맵, 셋, DOM 노드리스트 등)들이 '순회 가능'이라는 공통된 기능을 갖기 위해, 각자의 고유한 특성을 해치지 않으면서 이 기능을 유연하게 추가할 수 있도록 '인터페이스' 방식을 채택했습니다.

### 1. Web API의 NodeList도 이터러블:

- 웹 개발에서 자주 접하는 NodeList는 문서 내의 여러 DOM 노드(예: 특정 클래스 이름을 가진 모든 <p> 태그)들을 모아놓은 컬렉션입니다. NodeList는 배열과 비슷해 보이지만 실제 배열은 아닙니다. 하지만 이터러블 프로토콜을 따르기 때문에, 배열처럼 for...of 루프나 전개 연산자를 사용할 수 있습니다.

### 2. 왜 모든 순회 가능한 객체들이 Array를 상속하도록 만들지 않았을까?

만약 모든 순회 가능한 객체가 Array를 상속받아야 한다고 가정해 봅시다. 어떤 문제가 생길 수 있을까요?

- Array: 순서가 있는 숫자 인덱스 기반의 컬렉션입니다. push, pop, slice, splice 등 배열 고유의 강력한 메서드들을 가지고 있습니다. 데이터의 순서와 인덱스를 통한 접근이 중요할 때 사용합니다.
- Map: 키-값 쌍을 저장하는 컬렉션입니다. 각 키는 유일해야 하며, 키를 통해 값을 빠르게 검색, 추가, 삭제하는 데 특화되어 있습니다. (ES6 Map은 삽입 순서를 기억하지만, 본질적으로는 키 기반 접근이 중요합니다.)
- Set: 중복되지 않는 유일한 값들의 컬렉션입니다. 주로 값의 존재 여부를 빠르게 확인하거나, 중복을 제거하는 용도로 사용됩니다. (ES6 Set도 삽입 순서를 기억합니다.)

**만약 Map이나 Set이 Array를 상속받는다면:**

1. 불필요한 기능 상속: Map 객체에 mapInstance.push(...)나 setInstance.pop() 같은 배열 메서드가 생긴다면 매우 혼란스러울 것입니다. Map은 키-값 쌍으로 관리되므로 push의 개념이 어울리지 않고, Set은 순서보다는 값의 유일성이 중요하므로 pop 같은 연산이 주된 용도와 맞지 않습니다.
2. 고유 특성과의 충돌: Array는 숫자 인덱스를 강제합니다. 하지만 Map은 임의의 값을 키로 사용할 수 있습니다. Set도 값 자체가 중요하지, 특정 인덱스는 부차적입니다. Array를 상속하면 이런 고유한 데이터 관리 방식과 충돌하거나, 기능을 억지로 끼워 맞춰야 하는 상황이 발생할 수 있습니다.
3. 유지보수의 어려움: 부모 클래스인 Array의 내부 구현이 변경되면, 이를 상속받는 모든 자식 클래스들(Map, Set 등)이 예상치 못한 영향을 받을 수 있습니다. 이는 시스템 전체의 안정성을 떨어뜨립니다.

이들은 각자 다른 목적과 내부 구조, 최적화된 연산을 가지고 있습니다. 만약 모두 Array를 상속받는다면, Map이나 Set에 불필요한 배열의 속성/메서드가 생기거나, Array의 동작을 억지로 맞춰야 하는 문제가 발생합니다.

### 3. 인터페이스 vs. 클래스 상속:

- 인터페이스 (Interface): "무엇을 할 수 있는지" (행동의 규약)를 정의합니다. [Symbol.iterator]() 메서드가 있으면 "순회할 수 있다"는 인터페이스를 만족하는 것입니다. 서로 다른 클래스들이 동일한 인터페이스를 구현함으로써 다형성을 확보하고, 코드의 결합도를 낮춥니다. 언어/라이브러리 설계 시 선호됩니다.
- 상속 (Inheritance): "무엇인지" (구현과 속성을 물려받음)를 정의합니다. 코드 재사용에 유용하지만, 클래스 간 강한 결합을 만듭니다. 부모 클래스의 변경이 자식에게 영향을 미치거나, "is-a" 관계가 명확하지 않을 때 남용하면 문제가 생길 수 있습니다. 주로 애플리케이션 레벨에서 구체적인 로직을 확장할 때 사용됩니다.

### 4. 이터레이션 프로토콜의 장점:

- 상속 없이도 다양한 자료구조가 일관된 방식으로 순회될 수 있게 합니다.
- 각 자료구조는 자신의 고유한 특성을 유지하면서, '순회'라는 공통 기능만 인터페이스를 통해 제공합니다.
- 이는 시스템 전체의 유연성과 확장성을 높입니다.

결론적으로, 이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 것은 자바스크립트의 다양한 데이터 구조들이 각자의 특성을 살리면서도 '순회'라는 공통의 기능을 일관되고 유연하게 제공하기 위한 현명한 설계 결정이라고 할 수 있습니다.

---

## 1.6 요약 정리

이 장은 "반복"이라는 문제를 해결하기 위해 객체지향의 반복자 패턴, 함수형 프로그래밍의 일급 함수와 지연 평가, 그리고 명령형 프로그래밍의 제너레이터라는 각기 다른 패러다임의 도구들을 어떻게 자바스크립트의 이터레이션 프로토콜이라는 우산 아래 통합하고 활용하는지 보여줍니다. 이를 통해 개발자는 더 표현력 있고, 효율적이며, 재사용 가능한 코드를 작성할 수 있게 됩니다.
