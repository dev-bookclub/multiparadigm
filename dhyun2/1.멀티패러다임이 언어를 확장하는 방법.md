# 멀티 패러다임이 현대 언어를 확장하는 방법

&nbsp;이전에는 함수형을 사용하거나 객체지향을 사용하는 등 한 가지 패러다임을 쓰는 것을 추천하고 지향했지만, 오느날은 대부분 프로그래밍이 멀티 패러다임 언어로 발전하였습니다.

이를 너무 철학적, 개념적 관점으로 다가가면 오히려 성능이나 사용자 경험이 희생되므로, 모든 프로그래밍 패러다임은 성공적인 소프트웨어 개발을 위한 **도구**라고 생각해야 좋습니다.

이 책에서는 다양한 패러다임의 조화를 소개합니다.

## 1. 명령형 프로그래밍에서 이터레이터 패턴을 구현하는 제네레이터 함수

현대 프로그래밍 언어는 명확하게 한 가지 패러다임에 국한되지 않고, **함수형, 명령형, 객체지향**이 자연스럽게 조화를 이루는 **멀티 패러다임**으로 진화하고 있습니다. 이 장에서는 그 대표적인 예로서 **명령형 프로그래밍 방식에서 함수형적인 반복자 패턴을 구현하는 제네레이터 함수**를 다루고, 이를 바탕으로 이터레이션 프로토콜의 중요성과 설계 철학을 이해합니다.

---

### 제네레이터 함수와 명령형 반복자

자바스크립트의 제네레이터 함수(`function*`)는 명령형 코드 기반에서 반복자(Iterator) 패턴을 쉽고 간결하게 구현할 수 있게 해줍니다. `yield` 키워드를 활용하여 함수 실행을 일시 중단하고, 외부에서 `next()`로 제어 흐름을 명확하게 조작할 수 있어 함수형적 사고를 가능하게 합니다.

```ts
function* range(start: number, end: number) {
  for (let i = start; i < end; i++) {
    yield i;
  }
}

const gen = range(0, 3);
console.log([...gen]); // [0, 1, 2]
```

---

## 2. 이터레이션 프로토콜과 이터러블(Iterable)

자바스크립트의 **이터레이션 프로토콜(iteration protocol)** 은 반복 가능한 데이터를 순회하는 표준 규칙을 제공합니다. 이 규약을 따르는 객체는 **이터러블**이며, `for...of`, 전개 연산자(`...`), 구조 분해 할당 등 다양한 내장 문법에서 사용할 수 있습니다.

### 이터러블의 조건

```ts
const iterable = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        return i < 3 ? { value: i++, done: false } : { done: true };
      },
    };
  },
};

for (const value of iterable) {
  console.log(value); // 0, 1, 2
}
```

- `Symbol.iterator` 메서드를 가지면 **이터러블**이다.
- 이 메서드는 이터레이터 객체(즉, `next()`를 가진 객체)를 반환한다.

이 구조는 **반복자 패턴(Iterator Pattern)**의 객체지향적 설계 방식에서 착안한 것이다. 공통 인터페이스(`next()`)를 통해 다양한 자료구조를 동일한 방식으로 순회할 수 있도록 만든 디자인 패턴이다.

---

## 3. 왜 이터레이션 프로토콜인가? — 상속보다 인터페이스

### 상속 vs 인터페이스

| 항목 | 상속 (`extends`)                | 인터페이스 (`implements`)              |
| ---- | ------------------------------- | -------------------------------------- |
| 정의 | 부모 클래스의 구현까지 물려받음 | 메서드 시그니처만 정의하고 구현은 없음 |
| 특징 | 강한 결합, 계층적 구조          | 느슨한 결합, 유연한 조합 가능          |
| 예시 | `class A extends B {}`          | `interface A { foo(): void }`          |

**이터레이션 프로토콜은 '인터페이스 기반 설계'를 따른다.** 이것은 다음과 같은 이유 때문이다:

- 다양한 자료구조(`Array`, `Set`, `Map`, `NodeList`)가 **공통 기능** 은 공유하지만, **내부 구현**이나 최적화 방식은 다르기 때문
  -> 성능 최적화 및 유연성 때문

  ```
  Array
  - 인덱스 기반 빠른 접근
  - 연속적인 메모리 블록
  Set
  - 해시 기반 구조, 중복 제거등에 용이
  Map
  - 키-값 쌍 저장
  - 삽입 순서 보존
  NodeList
  - 브라우저 내부에서 DOM과 연결된 특별한 메모리 공간에서 관리(DOM과 연결된 메모리 포인터 같은 역할)
  ```

- 상속을 사용하면 부모 클래스의 구현까지 강제로 물려받게 되어 **불필요한 기능이나 부작용이 함께 전달됨**
  -> 최적화 및 성능부분에서 좋지 않음
- 대신, `Symbol.iterator()` 인터페이스만 정의하고, 각 타입이 자신의 방식대로 `next()` 로직을 구현할 수 있도록 유연하게 처리
  -> 이터레이션 프로토콜을 구현하여 **배열처럼 순회 가능하도록 설계**

---

## 4. iterator는 왜 `Symbol.iterator()`일까

### 1. 고유하고 충돌 없는 키가 필요하다

```javascript
const obj = {
  iterator() {
    // 사용자 정의 iterator?
  },
};
```

obj.iterator()라는 함수가 원래 존재했는데, 이걸 우연히 덮어쓰게 될 수도 있습니다.

> Symbol은 전역에서 유일한 식별자이므로, 충돌 방지

### 2. 엔진이 내부적으로 특별한 동작을 할 수 있도록 하기 위해

Symbol.iterator는 자바스크립트 엔진이 다음과 같은 문법에서 자동으로 호출하는 예약 키

```javascript
for (const item of myObj) { ... }
[...myObj]
```

이 문법은 내부적으로 myObj\[Symbol.iterator]()를 호출함.

> [링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...of?utm_source=chatgpt.com#for...of%EC%99%80_for...in%EC%9D%98_%EC%B0%A8%EC%9D%B4)

## 5. 함수형 라이브러리는 왜 map, filter를 제공할까?

lodash.map, lodash.filter 같은 함수는 단순히 Array.prototype.map의 대체제가 아니라, 다양한 컬렉션 유형을 대상으로 일관되게 동작하도록 만든 고수준 추상 함수입니다.

물론 배열뿐만 아니고, 객체를 다룰 수도 있으며, 아래와 같이 체이닝도 구현이 가능합니다.

```javascript
_.chain([1, 2, 3])
  .map((n) => n * 2)
  .filter((n) => n > 2)
  .value();
```

하지만 개인적인 사견으로 조금 철학적/이념적 관점으로 바라보면 `Array.prototype.map`는 함수형 스타일을 흉내 내는 명령형 객체 메서드입니다.

```javascript
[1, 2, 3].map((x) => x * 2); // [2, 4, 6]
```

물론 위 코드는 함수형 프로그래밍 규칙을 잘 지키고 있습니다.

- 불변성을 지키며, 새로운 배열을 리턴
- 순수함수를 받음
- 선언적

하지만 결국 위의 map은 배열의 `인스턴스 메서드` 입니다. 즉 데이터가 먼저 있어야하는 데이터 중심의 사고입니다.

이에반해 함수형 라이브러리로 시작되는 map, set들은 자료형에 의존하지 않는 point-free 스타일입니다.

```javascript
import { map, filter, flow } from 'lodash/fp';

const process = flow(
  map((x) => x * 2),
  filter((x) => x > 3)
);
```

위 코드와 같이. 데이터를 나중에 주입하며, 함수 자체가 조합 가능한 추상화된 흐름으로 구성되어 있습니다.

이를 요약하자면 아래의 개념과 같습니다.

> Array.prototype.map은 "배열이라는 객체 안에 정의된 함수형 스타일의 도구"지만,
> lodash.map은 "함수형 철학에 기반해 설계된 보편적 추상화 도구"입니다.
